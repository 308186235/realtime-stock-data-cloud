"""
åŒèŠ±é¡ºäº¤æ˜“æœåŠ¡APIè·¯ç”±
"""
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, WebSocket, WebSocketDisconnect
from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field
import logging
import json
import asyncio
import os
import time
import random
from datetime import datetime, timedelta

# åˆ›å»ºè·¯ç”±å™¨
router = APIRouter(prefix="/ths", tags=["tonghuashun"])

# æ¨¡å‹å®šä¹‰
class LoginRequest(BaseModel):
    account: str = Field(..., description="äº¤æ˜“è´¦å·")
    password: str = Field(..., description="äº¤æ˜“å¯†ç ")
    broker_type: str = Field(..., description="åˆ¸å•†ç±»å‹")
    verification_code: Optional[str] = Field(None, description="éªŒè¯ç ")

class OrderRequest(BaseModel):
    session_id: str = Field(..., description="ä¼šè¯ID")
    symbol: str = Field(..., description="è¯åˆ¸ä»£ç ")
    price: float = Field(..., description="å§”æ‰˜ä»·æ ¼")
    volume: int = Field(..., description="å§”æ‰˜æ•°é‡")
    direction: str = Field(..., description="äº¤æ˜“æ–¹å‘,'buy'æˆ–'sell'")
    order_type: str = Field("limit", description="è®¢å•ç±»å‹,'limit'(é™ä»·)æˆ–'market'(å¸‚ä»·)")

class CancelOrderRequest(BaseModel):
    session_id: str = Field(..., description="ä¼šè¯ID")
    order_id: str = Field(..., description="å§”æ‰˜ç¼–å·")

# ä¼šè¯å­˜å‚¨
active_sessions = {}

# ğŸš¨ ç¦ç”¨æ¨¡æ‹Ÿæ•°æ® - è¦æ±‚çœŸå®åŒèŠ±é¡ºAPIæ•°æ®
def get_real_account_info():
    """è·å–çœŸå®è´¦æˆ·ä¿¡æ¯ - ç¦ç”¨æ¨¡æ‹Ÿæ•°æ®"""
    raise ValueError("âŒ ç³»ç»Ÿç¦æ­¢ä½¿ç”¨æ¨¡æ‹Ÿè´¦æˆ·æ•°æ®ï¼Œè¯·é…ç½®çœŸå®åŒèŠ±é¡ºAPIæ¥å£")

mock_positions = [
    {
        "symbol": "600519",
        "name": "è´µå·èŒ…å°",
        "volume": 10,
        "available": 10,
        "cost_price": 1800.00,
        "current_price": 1826.50,
        "market_value": 18265.00,
        "profit_loss": 265.00,
        "profit_loss_ratio": 0.0147
    },
    {
        "symbol": "000858",
        "name": "äº”ç²®æ¶²",
        "volume": 50,
        "available": 50,
        "cost_price": 180.00,
        "current_price": 185.20,
        "market_value": 9260.00,
        "profit_loss": 260.00,
        "profit_loss_ratio": 0.0289
    }
]

mock_orders = [
    {
        "order_id": "2023051001",
        "symbol": "600519",
        "name": "è´µå·èŒ…å°",
        "price": 1825.00,
        "volume": 5,
        "direction": "BUY",
        "status": "FILLED",
        "submit_time": "2023-05-10 09:30:15",
        "traded_volume": 5
    },
    {
        "order_id": "2023051002",
        "symbol": "000858",
        "name": "äº”ç²®æ¶²",
        "price": 185.00,
        "volume": 20,
        "direction": "BUY",
        "status": "PARTIAL",
        "submit_time": "2023-05-10 10:15:32",
        "traded_volume": 10
    }
]

# ä¸œå´ç§€æ‰è´¦æˆ·æ¨¡æ‹Ÿæ•°æ®
dongwu_xiucai_account_info = {
    "balance": 150000.00,
    "available": 95000.00,
    "market_value": 55000.00,
    "total_assets": 150000.00,
    "frozen": 0.00
}

# ä¸œå´ç§€æ‰æŒä»“æ¨¡æ‹Ÿæ•°æ®
dongwu_xiucai_positions = [
    {
        "symbol": "600519",
        "name": "è´µå·èŒ…å°",
        "volume": 5,
        "available": 5,
        "cost_price": 1820.00,
        "current_price": 1836.50,
        "market_value": 9182.50,
        "profit_loss": 82.50,
        "profit_loss_ratio": 0.0045
    },
    {
        "symbol": "600036",
        "name": "æ‹›å•†é“¶è¡Œ",
        "volume": 500,
        "available": 500,
        "cost_price": 35.50,
        "current_price": 36.80,
        "market_value": 18400.00,
        "profit_loss": 650.00,
        "profit_loss_ratio": 0.0366
    }
]

# æ¨¡æ‹Ÿä½™é¢å†å²è®°å½•
mock_balance_history = []

# APIè·¯ç”±
@router.post("/login", response_model=Dict)
async def login(request: LoginRequest):
    """ç™»å½•åŒèŠ±é¡ºæ¥å£"""
    # è¿™é‡Œåªæ˜¯æ¨¡æ‹Ÿ,å®é™…åº”ç”¨ä¸­éœ€è¦ä¸åŒèŠ±é¡ºé€šä¿¡
    if request.account and request.password:
        session_id = f"ths_session_{int(time.time())}"
        active_sessions[session_id] = {
            "account": request.account,
            "broker_type": request.broker_type,
            "login_time": datetime.now().isoformat(),
            "last_activity": time.time()
        }
        
        return {
            "success": True,
            "message": "ç™»å½•æˆåŠŸ",
            "session_id": session_id
        }
    else:
        raise HTTPException(status_code=400, detail="è´¦å·æˆ–å¯†ç ä¸èƒ½ä¸ºç©º")

@router.post("/logout", response_model=Dict)
async def logout(session_id: str):
    """ç™»å‡ºåŒèŠ±é¡ºæ¥å£"""
    if session_id in active_sessions:
        del active_sessions[session_id]
        return {"success": True, "message": "å·²æˆåŠŸç™»å‡º"}
    else:
        return {"success": False, "message": "æ— æ•ˆçš„ä¼šè¯ID"}

@router.get("/account_info", response_model=Dict)
async def get_account_info(session_id: str):
    """è·å–è´¦æˆ·èµ„é‡‘ä¿¡æ¯"""
    if session_id not in active_sessions:
        return {"success": False, "message": "æ— æ•ˆçš„ä¼šè¯ID"}
    
    # æ£€æŸ¥æ˜¯å¦æ˜¯ä¸œå´ç§€æ‰è´¦æˆ·
    if active_sessions[session_id].get("broker_type") == "dongwu_xiucai":
        return {
            "success": True,
            "data": dongwu_xiucai_account_info
        }
    
    # ğŸš¨ ç¦ç”¨æ¨¡æ‹Ÿæ•°æ® - è¦æ±‚çœŸå®API
    raise HTTPException(status_code=400, detail="âŒ ç³»ç»Ÿç¦æ­¢è¿”å›æ¨¡æ‹Ÿè´¦æˆ·æ•°æ®ï¼Œè¯·é…ç½®çœŸå®åŒèŠ±é¡ºAPIæ¥å£")

@router.get("/positions", response_model=Dict)
async def get_positions(session_id: str):
    """è·å–æŒä»“åˆ—è¡¨"""
    if session_id not in active_sessions:
        return {"success": False, "message": "æ— æ•ˆçš„ä¼šè¯ID"}
    
    # æ£€æŸ¥æ˜¯å¦æ˜¯ä¸œå´ç§€æ‰è´¦æˆ·
    if active_sessions[session_id].get("broker_type") == "dongwu_xiucai":
        return {
            "success": True,
            "data": dongwu_xiucai_positions
        }
    
    return {
        "success": True,
        "data": mock_positions
    }

@router.post("/place_order", response_model=Dict)
async def place_order(request: OrderRequest):
    """ä¸‹å•"""
    if request.session_id not in active_sessions:
        return {"success": False, "message": "æ— æ•ˆçš„ä¼šè¯ID"}
    
    # ç”Ÿæˆè®¢å•ID
    order_id = f"order_{int(time.time())}"
    
    # è·å–è‚¡ç¥¨åç§° - å®é™…åº”ç”¨ä¸­åº”è¯¥ä»å¸‚åœºæ•°æ®è·å–
    stock_names = {
        "600519": "è´µå·èŒ…å°",
        "000858": "äº”ç²®æ¶²",
        "601318": "ä¸­å›½å¹³å®‰",
        "600036": "æ‹›å•†é“¶è¡Œ"
    }
    
    stock_name = stock_names.get(request.symbol, "æœªçŸ¥è‚¡ç¥¨")
    
    # åˆ›å»ºæ–°è®¢å•
    new_order = {
        "order_id": order_id,
        "symbol": request.symbol,
        "name": stock_name,
        "price": request.price,
        "volume": request.volume,
        "direction": request.direction.upper(),
        "status": "SUBMITTED",
        "submit_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "traded_volume": 0
    }
    
    # æ·»åŠ åˆ°è®¢å•åˆ—è¡¨ - å®é™…åº”ç”¨ä¸­åº”å‘é€åˆ°åŒèŠ±é¡º
    mock_orders.insert(0, new_order)
    
    return {
        "success": True,
        "message": "å§”æ‰˜å·²æäº¤",
        "data": {
            "order_id": order_id
        }
    }

@router.post("/cancel_order", response_model=Dict)
async def cancel_order(request: CancelOrderRequest):
    """æ’¤å•"""
    if request.session_id not in active_sessions:
        return {"success": False, "message": "æ— æ•ˆçš„ä¼šè¯ID"}
    
    # æŸ¥æ‰¾è®¢å•
    order_found = False
    for order in mock_orders:
        if order["order_id"] == request.order_id:
            if order["status"] in ["SUBMITTED", "PARTIAL", "QUEUED"]:
                order["status"] = "CANCELLED"
                order_found = True
            else:
                return {"success": False, "message": "è¯¥å§”æ‰˜çŠ¶æ€ä¸å¯æ’¤å•"}
    
    if not order_found:
        return {"success": False, "message": "æœªæ‰¾åˆ°æŒ‡å®šå§”æ‰˜"}
    
    return {
        "success": True,
        "message": "æ’¤å•è¯·æ±‚å·²æäº¤"
    }

@router.get("/orders", response_model=Dict)
async def get_orders(session_id: str, status: Optional[str] = None, 
                     start_date: Optional[str] = None, end_date: Optional[str] = None):
    """è·å–å§”æ‰˜åˆ—è¡¨"""
    if session_id not in active_sessions:
        return {"success": False, "message": "æ— æ•ˆçš„ä¼šè¯ID"}
    
    # ç­›é€‰è®¢å•
    filtered_orders = mock_orders
    
    if status:
        filtered_orders = [order for order in filtered_orders if order["status"] == status]
    
    # æ—¥æœŸè¿‡æ»¤é€»è¾‘å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ...
    
    return {
        "success": True,
        "data": filtered_orders
    }

@router.get("/trades", response_model=Dict)
async def get_trades(session_id: str, start_date: Optional[str] = None, end_date: Optional[str] = None):
    """è·å–æˆäº¤åˆ—è¡¨"""
    if session_id not in active_sessions:
        return {"success": False, "message": "æ— æ•ˆçš„ä¼šè¯ID"}
    
    # æ¨¡æ‹Ÿæˆäº¤æ•°æ® - ä»å·²æˆäº¤çš„è®¢å•ç”Ÿæˆ
    trades = []
    for order in mock_orders:
        if order["traded_volume"] > 0:
            trades.append({
                "trade_id": f"trade_{order['order_id']}",
                "order_id": order["order_id"],
                "symbol": order["symbol"],
                "name": order["name"],
                "price": order["price"],
                "volume": order["traded_volume"],
                "direction": order["direction"],
                "trade_time": order["submit_time"]  # ç®€åŒ–å¤„ç†,å®é™…åº”ä¸åŒ
            })
    
    return {
        "success": True,
        "data": trades
    }

@router.get("/quotes", response_model=Dict)
async def get_quotes(session_id: str, symbols: str):
    """è·å–å®æ—¶è¡Œæƒ…"""
    if session_id not in active_sessions:
        return {"success": False, "message": "æ— æ•ˆçš„ä¼šè¯ID"}
    
    # è§£æè‚¡ç¥¨ä»£ç 
    symbol_list = [s.strip() for s in symbols.split(",") if s.strip()]
    
    # ç”Ÿæˆæ¨¡æ‹Ÿè¡Œæƒ…æ•°æ®
    quotes = {}
    mock_prices = {
        "600519": 1826.50,
        "000858": 185.20,
        "601318": 45.67,
        "600036": 38.22
    }
    
    for symbol in symbol_list:
        if symbol in mock_prices:
            quotes[symbol] = {
                "symbol": symbol,
                "price": mock_prices[symbol],
                "open": mock_prices[symbol] * 0.99,
                "high": mock_prices[symbol] * 1.02,
                "low": mock_prices[symbol] * 0.98,
                "volume": 1000000,
                "amount": mock_prices[symbol] * 1000000,
                "last_close": mock_prices[symbol] * 0.995
            }
    
    return {
        "success": True,
        "data": quotes
    }

@router.get("/balance/history", response_model=Dict)
async def get_balance_history(session_id: str, start_date: Optional[str] = None, end_date: Optional[str] = None):
    """è·å–è´¦æˆ·ä½™é¢å†å²å˜åŒ–è®°å½•"""
    if session_id not in active_sessions:
        return {"success": False, "message": "æ— æ•ˆçš„ä¼šè¯ID"}
    
    # ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®
    if not mock_balance_history:
        # è®¾ç½®é»˜è®¤æ—¥æœŸèŒƒå›´ä¸ºè¿‡å»30å¤©
        end_date_obj = datetime.now()
        if end_date:
            try:
                end_date_obj = datetime.strptime(end_date, "%Y-%m-%d")
            except ValueError:
                pass
        
        start_date_obj = end_date_obj - timedelta(days=30)
        if start_date:
            try:
                start_date_obj = datetime.strptime(start_date, "%Y-%m-%d")
            except ValueError:
                pass
        
        # ç”Ÿæˆæ¯ä¸€å¤©1-3æ¡è®°å½•
        current_date = start_date_obj
        while current_date <= end_date_obj:
            # æ¯å¤©ç”Ÿæˆ1-3æ¡è®°å½•
            for _ in range(random.randint(1, 3)):
                # éšæœºäº¤æ˜“æ—¶é—´(9:30-15:00)
                trade_hour = random.randint(9, 14)
                trade_minute = random.randint(0, 59)
                if trade_hour == 9 and trade_minute < 30:
                    trade_minute = 30 + random.randint(0, 29)
                
                trade_time = current_date.replace(hour=trade_hour, minute=trade_minute)
                
                # éšæœºäº¤æ˜“ç±»å‹
                is_buy = random.random() > 0.5
                
                # éšæœºè‚¡ç¥¨
                stock_index = random.randint(0, len(mock_positions) - 1)
                stock = mock_positions[stock_index]
                
                # éšæœºäº¤æ˜“é‡
                volume = random.randint(100, 1000)
                # éšæœºä»·æ ¼æ³¢åŠ¨
                price_change = (random.random() - 0.5) * 0.05  # Â±2.5%
                price = stock["current_price"] * (1 + price_change)
                
                # è®¡ç®—äº¤æ˜“é‡‘é¢
                amount = price * volume
                
                # è®¡ç®—è´¹ç”¨
                commission_rate = 0.0003  # ä½£é‡‘è´¹ç‡
                transfer_fee_rate = 0.00002  # è¿‡æˆ·è´¹è´¹ç‡(ä¸Šäº¤æ‰€)
                stamp_duty_rate = 0.001  # å°èŠ±ç¨(å–å‡ºæ—¶æ”¶å–)
                
                commission = max(amount * commission_rate, 5)  # ä½£é‡‘æœ€ä½5å…ƒ
                transfer_fee = 0
                if stock["symbol"].startswith("6"):  # ä¸Šæµ·è‚¡ç¥¨
                    transfer_fee = max(amount * transfer_fee_rate, 1)  # è¿‡æˆ·è´¹æœ€ä½1å…ƒ
                
                stamp_duty = 0
                if not is_buy:
                    stamp_duty = amount * stamp_duty_rate
                
                total_fee = commission + transfer_fee + stamp_duty
                
                # è®¡ç®—ä½™é¢å˜åŒ–
                balance_change = -amount - total_fee if is_buy else amount - total_fee
                
                # ç”Ÿæˆè®°å½•
                mock_balance_history.append({
                    "id": f"record_{len(mock_balance_history) + 1}",
                    "time": int(trade_time.timestamp() * 1000),
                    "balance": balance_change,
                    "tradeId": f"trade_{int(trade_time.timestamp())}",
                    "type": "BUY" if is_buy else "SELL",
                    "symbol": stock["symbol"],
                    "name": stock["name"],
                    "price": round(price, 2),
                    "volume": volume,
                    "description": f"{'ä¹°å…¥' if is_buy else 'å–å‡º'} {stock['name']}({stock['symbol']}) {volume}è‚¡",
                    "fees": {
                        "total": round(total_fee, 2),
                        "stampDuty": round(stamp_duty, 2),
                        "commission": round(commission, 2),
                        "transferFee": round(transfer_fee, 2)
                    }
                })
            
            # ä¸‹ä¸€å¤©
            current_date += timedelta(days=1)
    
    # æŒ‰æ—¶é—´æˆ³æ’åº
    sorted_history = sorted(mock_balance_history, key=lambda x: x["time"], reverse=True)
    
    # å¦‚æœæŒ‡å®šäº†æ—¥æœŸèŒƒå›´,è¿›è¡Œè¿‡æ»¤
    if start_date or end_date:
        filtered_history = []
        start_timestamp = None
        end_timestamp = None
        
        if start_date:
            try:
                start_date_obj = datetime.strptime(start_date, "%Y-%m-%d")
                start_timestamp = int(start_date_obj.timestamp() * 1000)
            except ValueError:
                pass
        
        if end_date:
            try:
                end_date_obj = datetime.strptime(end_date, "%Y-%m-%d")
                end_date_obj = end_date_obj.replace(hour=23, minute=59, second=59)
                end_timestamp = int(end_date_obj.timestamp() * 1000)
            except ValueError:
                pass
        
        for record in sorted_history:
            include = True
            if start_timestamp and record["time"] < start_timestamp:
                include = False
            if end_timestamp and record["time"] > end_timestamp:
                include = False
            
            if include:
                filtered_history.append(record)
        
        sorted_history = filtered_history
    
    return {
        "success": True,
        "data": sorted_history
    }

# WebSocketè¿æ¥ä»¥è·å–å®æ—¶æ•°æ®
@router.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    """WebSocketè¿æ¥è·å–å®æ—¶è¡Œæƒ…å’Œå§”æ‰˜çŠ¶æ€æ›´æ–°"""
    await websocket.accept()
    
    if session_id not in active_sessions:
        await websocket.send_text(json.dumps({
            "success": False,
            "message": "æ— æ•ˆçš„ä¼šè¯ID"
        }))
        await websocket.close()
        return
    
    try:
        while True:
            # æ¨¡æ‹Ÿå®šæœŸå‘é€æ›´æ–°
            await asyncio.sleep(2)
            
            # æ¨¡æ‹Ÿæ•°æ®å˜åŒ–
            for position in mock_positions:
                # éšæœºä»·æ ¼æ³¢åŠ¨
                price_change = position["current_price"] * (0.98 + 0.04 * time.time() % 1)
                position["current_price"] = round(price_change, 2)
                position["market_value"] = round(position["current_price"] * position["volume"], 2)
                position["profit_loss"] = round(position["market_value"] - position["cost_price"] * position["volume"], 2)
                position["profit_loss_ratio"] = round(position["profit_loss"] / (position["cost_price"] * position["volume"]), 4)
            
            # æ›´æ–°è´¦æˆ·æ€»èµ„äº§
            total_market_value = sum(p["market_value"] for p in mock_positions)
            mock_account_info["market_value"] = total_market_value
            mock_account_info["total_assets"] = mock_account_info["balance"] + total_market_value
            
            # å‘é€æ›´æ–°
            await websocket.send_text(json.dumps({
                "type": "update",
                "data": {
                    "account": mock_account_info,
                    "positions": mock_positions
                }
            }))
            
    except WebSocketDisconnect:
        # å®¢æˆ·ç«¯æ–­å¼€è¿æ¥
        pass
    except Exception as e:
        logging.error(f"WebSocketå¼‚å¸¸: {str(e)}")
        await websocket.close() 
